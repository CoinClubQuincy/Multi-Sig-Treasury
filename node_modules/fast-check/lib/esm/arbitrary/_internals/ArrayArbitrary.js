import { Stream } from '../../stream/Stream.js';
import { cloneIfNeeded, cloneMethod } from '../../check/symbols.js';
import { integer } from '../integer.js';
import { makeLazy } from '../../stream/LazyIterableIterator.js';
import { buildCompareFilter } from './helpers/BuildCompareFilter.js';
import { NextArbitrary } from '../../check/arbitrary/definition/NextArbitrary.js';
import { convertToNext } from '../../check/arbitrary/definition/Converters.js';
import { NextValue } from '../../check/arbitrary/definition/NextValue.js';
export class ArrayArbitrary extends NextArbitrary {
    constructor(arb, minLength, maxLength, isEqual) {
        super();
        this.arb = arb;
        this.minLength = minLength;
        this.maxLength = maxLength;
        this.isEqual = isEqual;
        this.lengthArb = convertToNext(integer(minLength, maxLength));
        this.preFilter = this.isEqual !== undefined ? buildCompareFilter(this.isEqual) : (tab) => tab;
    }
    static makeItCloneable(vs, shrinkables) {
        vs[cloneMethod] = () => {
            const cloned = [];
            for (let idx = 0; idx !== shrinkables.length; ++idx) {
                cloned.push(shrinkables[idx].value);
            }
            this.makeItCloneable(cloned, shrinkables);
            return cloned;
        };
        return vs;
    }
    canAppendItem(items, newItem) {
        if (this.isEqual === undefined) {
            return true;
        }
        for (let idx = 0; idx !== items.length; ++idx) {
            if (this.isEqual(items[idx].value_, newItem.value_)) {
                return false;
            }
        }
        return true;
    }
    wrapper(itemsRaw, shrunkOnce, itemsRawLengthContext) {
        const items = shrunkOnce ? this.preFilter(itemsRaw) : itemsRaw;
        let cloneable = false;
        const vs = [];
        for (let idx = 0; idx !== items.length; ++idx) {
            const s = items[idx];
            cloneable = cloneable || s.hasToBeCloned;
            vs.push(s.value);
        }
        if (cloneable) {
            ArrayArbitrary.makeItCloneable(vs, items);
        }
        const context = {
            shrunkOnce,
            lengthContext: itemsRaw.length === items.length && itemsRawLengthContext !== undefined
                ? itemsRawLengthContext
                : undefined,
            itemsContexts: items.map((v) => v.context),
        };
        return new NextValue(vs, context);
    }
    generate(mrng, biasFactor) {
        const biasMeta = this.applyBias(mrng, biasFactor);
        const targetSize = biasMeta.size;
        let numSkippedInRow = 0;
        const items = [];
        while (items.length < targetSize && numSkippedInRow < this.maxLength) {
            const current = this.arb.generate(mrng, biasMeta.biasFactorItems);
            if (this.canAppendItem(items, current)) {
                numSkippedInRow = 0;
                items.push(current);
            }
            else {
                numSkippedInRow += 1;
            }
        }
        return this.wrapper(items, false, undefined);
    }
    applyBias(mrng, biasFactor) {
        if (biasFactor === undefined || mrng.nextInt(1, biasFactor) !== 1) {
            return { size: this.lengthArb.generate(mrng, undefined).value };
        }
        if (mrng.nextInt(1, biasFactor) !== 1 || this.minLength === this.maxLength) {
            return { size: this.lengthArb.generate(mrng, undefined).value, biasFactorItems: biasFactor };
        }
        const maxBiasedLength = this.minLength + Math.floor(Math.log(this.maxLength - this.minLength) / Math.log(2));
        const targetSizeValue = convertToNext(integer(this.minLength, maxBiasedLength)).generate(mrng, undefined);
        return { size: targetSizeValue.value, biasFactorItems: biasFactor };
    }
    canShrinkWithoutContext(value) {
        if (!Array.isArray(value) || this.minLength > value.length || value.length > this.maxLength) {
            return false;
        }
        for (let index = 0; index !== value.length; ++index) {
            if (!(index in value)) {
                return false;
            }
            if (!this.arb.canShrinkWithoutContext(value[index])) {
                return false;
            }
        }
        const filtered = this.preFilter(value.map((item) => new NextValue(item, undefined)));
        return filtered.length === value.length;
    }
    shrinkImpl(value, context) {
        if (value.length === 0) {
            return Stream.nil();
        }
        const safeContext = context !== undefined
            ? context
            : { shrunkOnce: false, lengthContext: undefined, itemsContexts: [] };
        return (this.lengthArb
            .shrink(value.length, safeContext.lengthContext)
            .drop(safeContext.shrunkOnce && safeContext.lengthContext === undefined && value.length > this.minLength + 1 ? 1 : 0)
            .map((lengthValue) => {
            const sliceStart = value.length - lengthValue.value;
            return [
                value
                    .slice(sliceStart)
                    .map((v, index) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[index + sliceStart])),
                lengthValue.context,
            ];
        })
            .join(this.arb.shrink(value[0], safeContext.itemsContexts[0]).map((v) => {
            return [
                [v].concat(value.slice(1).map((v, index) => new NextValue(cloneIfNeeded(v), safeContext.itemsContexts[index + 1]))),
                undefined,
            ];
        }))
            .join(value.length > this.minLength
            ? makeLazy(() => this.shrinkImpl(value.slice(1), {
                shrunkOnce: false,
                lengthContext: undefined,
                itemsContexts: safeContext.itemsContexts.slice(1),
            })
                .filter((v) => this.minLength <= v[0].length + 1)
                .map((v) => {
                return [
                    [new NextValue(cloneIfNeeded(value[0]), safeContext.itemsContexts[0])].concat(v[0]),
                    undefined,
                ];
            }))
            : Stream.nil()));
    }
    shrink(value, context) {
        return this.shrinkImpl(value, context).map((contextualValue) => this.wrapper(contextualValue[0], true, contextualValue[1]));
    }
}
